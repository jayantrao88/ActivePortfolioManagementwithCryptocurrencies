---
title: "4c Portfolio Optimization CryptoFund"
output: html_notebook
---

library(fBasics)
library(readxl)
library(gdata)
library(PortfolioAnalytics)
library(PerformanceAnalytics)
library(ROI)
#library(flextable)
#library(officer)
library(dplyr)
library(gdata)
library(profvis)
library(tictoc)
library(rlist)
library(parallel)
library(DEoptim)
library(pso)
library(GenSA)
library(pbmcapply)
library(foreach)
library(DEoptim)
library(iterators)
library(fGarch)
library(Rglpk)
library(quadprog)
library(ROI)
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
library(ROI.plugin.symphony)
library(pso)
library(GenSA)
library(corpcor)
library(testthat)
library(nloptr)
library(MASS)
library(robustbase)
```{r, echo=FALSE, include=FALSE}


```

```{r}
library(tictoc)
library(PortfolioAnalytics)
library(rlist)
library(parallel)
```



```{r}
Unequal_df <- function(LIST){
  
NoofRebalPeriod <- length(LIST)

out <-   data.frame(matrix(nrow = NoofRebalPeriod, ncol = length(LIST[[NoofRebalPeriod]])))
colnames(out)  <- names(LIST[[NoofRebalPeriod]])  

for (PeriodNo in 1:NoofRebalPeriod){
unlis <-  unlist(LIST[[PeriodNo]])
  out[PeriodNo,names(unlis)] <- t(unlis) 
  rm(unlis)  
}
output <- out  
}
```



With the set of simulated returns I will be optimizing the portoflio(calculating the optimal portfolio weights) using different optimization techniques.

Optimization Techniques

1) 1/N or Naive Portfolio
2) Minimum Standard Deviation Portfolio
3) Minimum Expected Shortfall Portfolio
4) Sharpe Portfolio
5) STARR Portfolio
6) Maximum Mean Portfolio

Initializing the variables -- PortfolioWeights and PortfolioOptimization.
```{r, echo=FALSE}

PortfolioWeights <- list(NaivePortfolio = list(), MinSD = list(), MinES = list(), Sharpe = list(), Starr = list(), 
                         MaxMean = list())

PortfolioOptimization <- list( MinSD = list(), MinES = list(), Sharpe = list(), Starr = list(), 
                              MaxMean = list())
```

1) 1/N or Naive Portfolio

```{r, echo=FALSE}



if (length(PortfolioWeights[["NaivePortfolio"]]) != 0 ){PortfolioWeights[["NaivePortfolio"]] <- list()}

simreturns <- Sim.Returns
Pweights <- list()

for (CopulaType in 1:4){
  AssetsforOptimization = simreturns[[CopulaType]]
  NoofRebalPeriod = length(AssetsforOptimization)

  weights <- list()

  for (PeriodNo in 1:NoofRebalPeriod){
    NoofAssets <- ncol(AssetsforOptimization[[PeriodNo]])
    
    Rownames <- colnames(AssetsforOptimization[[PeriodNo]])
    TempWeights <- as.numeric(rep(1/NoofAssets, each = NoofAssets))
    names(TempWeights) <- Rownames
    weights <- list.append(weights,TempWeights)
  }
  weights <- Unequal_df(weights)
  Pweights <- list.append(Pweights, weights)
}

names(Pweights) <- c("P.R.Naive.Weights","P.C.Naive.Weights","E.R.Naive.Weights","E.C.Naive.Weights")
PortfolioWeights[["NaivePortfolio"]] <- Pweights

rm(AssetsforOptimization, PeriodNo, NoofAssets, Rownames,TempWeights, weights, CopulaType, NoofRebalPeriod, 
   simreturns, Pweights)

```

2) Minimum Standard Deviation Portfolio

```{r,echo=FALSE}

     
if (length(PortfolioWeights[["MinSD"]]) != 0 )
  {PortfolioWeights[["MinSD"]] <- list()}
if (length(PortfolioOptimization[["MinSD"]]) != 0 )
  {PortfolioOptimization[["MinSD"]] <- list()}
  
simreturns <- Sim.Returns
Pweights <- list()
Popt <- list()

for (CopulaType in 1:4){
  tic(sprintf("CopulaType %d", CopulaType))    
  AssetsforOptimization = simreturns[[CopulaType]]
  NoofRebalPeriod = length(AssetsforOptimization)
  weights <-  opt <- list()
  
  MinSDOpt <- function(AssetOptim){
                    init.portfolio <- portfolio.spec(assets = colnames(AssetOptim))
                    #init.portfolio <- add.constraint(portfolio = init.portfolio, type = "full_investment") or
                     init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", 
                                                     min_sum = 0.99, max_sum = 1.01) 
                     init.portfolio <- add.constraint(portfolio = init.portfolio, type = "long_only") 
                   
                    init.portfolio <- add.objective(portfolio=init.portfolio, type="risk", name="var")
                    optimized <- optimize.portfolio(R = AssetOptim, portfolio = init.portfolio, 
                                       optimize_method = "ROI",trace = TRUE,message = T)
                    out <- optimized
                    return(out)
  }
  
  numCores <- detectCores()
 #For Mac
  opt <- parallel::mclapply(AssetsforOptimization,MinSDOpt, mc.cores = numCores)
  #For Windows
  #opt <- parallelsugar::mclapply(AssetsforOptimization,MinSDOpt, mc.cores = numCores)
  weights <- lapply(opt, function(x){x$weights})
  
  weights <- Unequal_df(weights)
  Pweights <- list.append(Pweights, weights)
  
  Popt <- list.append(Popt, opt)
  toc()
}
names(Pweights) <- c("P.R.MinSD.Weights","P.C.MinSD.Weights","E.R.MinSD.Weights","E.C.MinSD.Weights")

names(Popt) <- c("P.R.MinSD.Optimization","P.C.MinSD.Optimization","E.R.MinSD.Optimization","E.C.MinSD.Optimization")
PortfolioWeights[["MinSD"]] <- Pweights
PortfolioOptimization[["MinSD"]] <- Popt
rm(opt,weights, CopulaType, NoofRebalPeriod, AssetsforOptimization,simreturns,Pweights,Popt,MinSDOpt,numCores)
```

3) Minimum Expected Shortfall Portfolio

```{r}
 
if (length(PortfolioWeights[["MinES"]]) != 0 )
  {PortfolioWeights[["MinES"]] <- list()}
if (length(PortfolioOptimization[["MinES"]]) != 0 )
  {PortfolioOptimization[["MinES"]] <- list()}
  
simreturns <- Sim.Returns
Pweights <- list()
Popt <- list()

if (length(PortfolioWeights[["MinES"]]) != 0 )
  {PortfolioWeights[["MinES"]] <- list()}
if (length(PortfolioOptimization[["MinES"]]) != 0 )
  {PortfolioOptimization[["MinES"]] <- list()}

for (CopulaType in 1:4){
  tic(sprintf("CopulaType %d", CopulaType))    
  AssetsforOptimization = simreturns[[CopulaType]]
  NoofRebalPeriod = length(AssetsforOptimization)
  weights <- opt <- list()
  
    MinESopt <- function(AssetOptim){
                init.portfolio <- portfolio.spec(assets = colnames(AssetOptim))
               #init.portfolio <- add.constraint(portfolio = init.portfolio, type = "full_investment") or
                     init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", 
                                                     min_sum = 0.99, max_sum = 1.01) 
                     init.portfolio <- add.constraint(portfolio = init.portfolio, type = "long_only") 
                
                init.portfolio <- add.objective(portfolio=init.portfolio, type="risk", name="ES")
                optimized <- optimize.portfolio(R = AssetOptim, portfolio = init.portfolio, 
                         optimize_method = "ROI",trace = TRUE,message = T)
                out <- optimized
                return(out)
                }
  numCores <- detectCores() 
  opt <- pbmcapply::pbmclapply(AssetsforOptimization,MinESopt, mc.cores = numCores)
  weights <- lapply(opt, function(x){x$weights})
  weights <- Unequal_df(weights)
  Pweights <- list.append(Pweights, weights)
  Popt <- list.append(Popt, opt)
  toc()
}
names(Pweights) <- c("P.R.MinES.Weights","P.C.MinES.Weights","E.R.MinES.Weights","E.C.MinES.Weights")
names(Popt) <- c("P.R.MinES.Optimization","P.C.MinES.Optimization","E.R.MinES.Optimization","E.C.MinES.Optimization")

PortfolioWeights[["MinES"]] <- Pweights
PortfolioOptimization[["MinES"]] <- Popt

rm(opt, weights, CopulaType, NoofRebalPeriod, AssetsforOptimization, simreturns,Pweights,Popt,MinESopt,numCores)
toc()

```

4) Sharpe Portfolio

```{r}
  
if(length(PortfolioWeights[["Sharpe"]]) != 0 ){
    PortfolioWeights[["Sharpe"]] <- list()}
if(length(PortfolioOptimization[["Sharpe"]]) != 0 ){
  PortfolioOptimization[["Sharpe"]] <- list()}

simreturns <- Sim.Returns
Pweights <- list()
Popt <- list()
#CopulaType <- 1
for (CopulaType in 1:4){
  tic(sprintf("CopulaType %d", CopulaType))   
  AssetsforOptimization = simreturns[[CopulaType]]
  NoofRebalPeriod = length(AssetsforOptimization)
  weights <-  opt <- list()

   Sharpeopt <- function(AssetOptim){
                init.portfolio <- portfolio.spec(assets = colnames(AssetOptim))
                #init.portfolio <- add.constraint(portfolio = init.portfolio, type = "full_investment") or
                init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", 
                                                     min_sum = 0.99, max_sum = 1.01) 
                init.portfolio <- add.constraint(portfolio = init.portfolio, type = "long_only") 
                
                
                init.portfolio <- add.objective(portfolio=init.portfolio,type="return", name="mean")
                init.portfolio <- add.objective(portfolio=init.portfolio,type="risk", name="StdDev")
                optimized <- optimize.portfolio(R = AssetOptim, portfolio = init.portfolio, 
                         optimize_method = "ROI",trace = TRUE, maxSR = TRUE,message = T)
                out <- optimized
                return(out)
                }
  numCores <- detectCores() 
  #For Mac
  opt <- parallel::mclapply(AssetsforOptimization,Sharpeopt, mc.cores = numCores)
  # For Windows
  #opt <- parallelsugar::mclapply(AssetsforOptimization,Sharpeopt, mc.cores = numCores)
  weights <- lapply(opt, function(x){x$weights})
  weights <- Unequal_df(weights)
  Pweights <- list.append(Pweights, weights)
  Popt <- list.append(Popt, opt)
  toc()
}
names(Pweights) <- c("P.R.Sharpe.Weights","P.C.Sharpe.Weights","E.R.Sharpe.Weights","E.C.Sharpe.Weights")
names(Popt) <- c("P.R.Sharpe.Optimization","P.C.Sharpe.Optimization","E.R.Sharpe.Optimization","E.C.Sharpe.Optimization")


PortfolioWeights[["Sharpe"]] <- Pweights
PortfolioOptimization[["Sharpe"]] <- Popt

rm(opt, weights, CopulaType, NoofRebalPeriod, AssetsforOptimization,simreturns, Sharpeopt,numCores)

```

5) STARR Portfolio

```{r}


if (length(PortfolioWeights[["Starr"]]) != 0 ){PortfolioWeights[["Starr"]] <- list()}
if (length(PortfolioOptimization[["Starr"]]) != 0 ){PortfolioOptimization[["Starr"]] <- list()}

simreturns <- Sim.Returns
Pweights <- list()
Popt <- list()  

 
Staropt <- function(AssetOptim){
                    init.portfolio <- portfolio.spec(assets = colnames(AssetOptim))
                    #init.portfolio <- add.constraint(portfolio = init.portfolio, type =                            "full_investment") or
                    init.portfolio <- add.constraint(portfolio = init.portfolio, type =      
                                                       "weight_sum", min_sum = 0.99, max_sum =
                                                       1.01) 
                    init.portfolio <- add.constraint(portfolio = init.portfolio, type 
                                                     ="long_only")
                    init.portfolio <- add.objective(portfolio=init.portfolio, type="risk", 
                                                    name="ES")
                    init.portfolio <- add.objective(portfolio=init.portfolio, type="return", 
                                                    name="mean")
                    optimized <- optimize.portfolio(R = AssetOptim, portfolio = 
                                                      init.portfolio, optimize_method = 
                                                      "ROI",trace = TRUE, maxSTARR = 
                                                      TRUE,message = T)
                    out <- optimized
                    return(out)
                    }


for (CopulaType in 1:4){
  tic(sprintf("CopulaType %d", CopulaType))  
  AssetsforOptimization = simreturns[[CopulaType]]
  NoofRebalPeriod = length(AssetsforOptimization)
  weights <-  opt <- list()
 
  numCores <- detectCores() 
  #For Mac
  opt <- parallel::mclapply(AssetsforOptimization,Staropt, mc.cores = numCores)
  # For Windows
  #opt <- parallelsugar::mclapply(AssetsforOptimization,Staropt, mc.cores = numCores)
  weights <- lapply(opt, function(x){x$weights})


  weights <- Unequal_df(weights)
  Pweights <- list.append(Pweights, weights)
  Popt <- list.append(Popt, opt)
  
  toc()
}
names(Pweights) <- c("P.R.Starr.Weights","P.C.Starr.Weights","E.R.Starr.Weights","E.C.Starr.Weights")
names(Popt) <- c("P.R.Starr.Optimization","P.C.Starr.Optimization","E.R.Starr.Optimization","E.C.Starr.Optimization")

PortfolioWeights[["Starr"]] <- Pweights
PortfolioOptimization[["Starr"]] <- Popt


rm(opt, weights, CopulaType, NoofRebalPeriod, AssetsforOptimization, simreturns,Pweights,Popt,Staropt,numCores)
toc()


```

6) Maximum Mean Portfolio

```{r}



if (length(PortfolioWeights[["MaxMean"]]) != 0 )
  {PortfolioWeights[["MaxMean"]] <- list()}
if (length(PortfolioOptimization[["MaxMean"]]) != 0 )
  {PortfolioOptimization[["MaxMean"]] <- list()}

simreturns <- Sim.Returns
Pweights <- list()
Popt <- list()  

for (CopulaType in 1:4){
  AssetsforOptimization = simreturns[[CopulaType]]
  NoofRebalPeriod = length(AssetsforOptimization)
  weights <-  opt <- list()
  
  
    MaxMeanopt <- function(AssetOptim){
                          init.portfolio <- portfolio.spec(assets = colnames(AssetOptim))
                          #init.portfolio <- add.constraint(portfolio = init.portfolio, type = "full_investment") or
                          init.portfolio <- add.constraint(portfolio = init.portfolio, type = "weight_sum", 
                                                     min_sum = 0.99, max_sum = 1.01) 
                          init.portfolio <- add.constraint(portfolio = init.portfolio, type = "long_only") 
                          
                          init.portfolio <- add.objective(portfolio=init.portfolio, type="return", name="mean")
                          optimized <- optimize.portfolio(R = AssetOptim, portfolio = init.portfolio, 
                                   optimize_method = "ROI",trace = TRUE, maxSR = TRUE,message = T)
                          out <- optimized
                          return(out)
                          }
                        
  numCores <- detectCores() 
  opt <- pbmcapply::pbmclapply(AssetsforOptimization,MaxMeanopt, mc.cores = numCores)
  weights <- lapply(opt, function(x){x$weights})
  weights <- Unequal_df(weights)
  Pweights <- list.append(Pweights, weights)
  Popt <- list.append(Popt, opt)

}
names(Pweights) <- c("P.R.MaxMean.Weights","P.C.MaxMean.Weights","E.R.MaxMean.Weights","E.C.MaxMean.Weights")
names(Popt) <- c("P.R.MaxMean.Optimization","P.C.MaxMean.Optimization","E.R.MaxMean.Optimization",
                 "E.C.MaxMean.Optimization")

PortfolioWeights[["MaxMean"]] <- Pweights
PortfolioOptimization[["MaxMean"]] <- Popt

rm(opt, weights, CopulaType, NoofRebalPeriod, AssetsforOptimization,simreturns,Pweights,Popt,MaxMeanopt,numCores)


```


Part 5 : Proceed to Backtesting
